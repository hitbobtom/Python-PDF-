第1章 JVM与Java体系结构	13
	1.1 为什么要学习JVM	13
	1.2 Java及JVM的简介	13
		1.2.1 Java:跨平台的语言	13
		1.2.2 JVM:跨语言的平台	15
	1.3 Java发展的重大事件	17
	1.4 Open JDK和Oracle JDK	18
	1.5 虚拟机与JVM	18
		1.5.1 虚拟机	18
		1.5.2 JVM	19
	1.6 JVM的整体结构	19
	1.7 Java代码执行流程	20
	1.8 JVM的架构模型	20
	1.9 JVM的生命周期	24
	1.10 JVM的发展历程	25
		1.10.1 Sun Classic VM	25
		1.10.2 Exact VM	25
		1.10.3 HotSpot VM	25
		1.10.4 BEA的JRockit	26
		1.10.5 IBM的J9	26
		1.10.6 KVM和CDC/CLDC HotSpot	26
		1.10.7 Azul VM	27
		1.10.8 Liquid VM	27
		1.10.9 Apache Harmony	27
		1.10.10 Microsoft JVM	27
		1.10.11 Taobao JVM	28
		1.10.12 Dalvik VM/ART VM	28
		1.10.13 Graal VM	28
		1.10.14 其他 JVM	29
	1.11 本章小结	29
第2章 运行时数据区及线程概述	31
	2.1 运行时数据区概述	31
	2.2 线程	32
	2.3 本章小结	32
第3章 程序计数器	33
	3.1 程序计数器介绍	33
	3.2 程序计数器举例说明	33
	3.3 程序计数器常见问题	34
	3.4 本章小结	34
第4章 虚拟机栈	35
	4.1 虚拟机栈概述	35
	4.2 栈的存储单位	39
	4.3 局部变量表	42
		4.3.1 局部变量表简介	42
		4.3.2 Slot	43
	4.4 操作数栈	45
	4.5 栈顶缓存技术	48
	4.6 动态链接	48
	4.7 方法的调用	49
		4.7.1 方法调用的分类	49
		4.7.2 虚方法与非虚方法	51
		4.7.3 关于invokedynamic指令	54
		4.7.4 方法重写的本质	55
		4.7.5 虚方法表	55
	4.8 方法返回地址	58
	4.9 本章小结	62
第5章 本地方法接口	63
	5.1 本地方法接口概述	63
	5.2 本章小结	64
第6章 本地方法栈	65
	6.1 本地方法栈概述	65
	6.2 本章小结	66
第7章 堆	67
	7.1 堆的核心概述	67
		7.1.1 JVM实例与堆内存的对应关系	67
		7.1.2 堆与栈的关系	69
		7.1.3 JVM堆空间划分	70
	7.2 设置堆内存大小与内存溢出	71
		7.2.1 设置堆内存大小	71
		7.2.2 内存溢出案例	73
	7.3 新生代与老年代	75
	7.4 图解对象分配过程	77
	7.5 Minor GC、Major GC、Full GC	80
		7.5.1 GC的分类	80
		7.5.2 分代式GC策略的触发条件	81
		7.5.3 GC举例	81
	7.6 堆空间分代思想	83
	7.7 堆中对象的分配策略	83
	7.8 为对象分配内存:TLAB	84
	7.9 堆空间的参数设置小结	86
	7.10 堆是否为分配对象存储的唯一选择	86
		7.10.1 对象不一定存储在堆中	86
		7.10.2 逃逸分析概述	87
		7.10.3 逃逸分析优化结果	88
		7.10.4 逃逸分析之栈上分配	89
		7.10.5 逃逸分析之同步省略	90
		7.10.6 逃逸分析之标量替换	92
		7.10.7 逃逸分析小结:逃逸分析并不成熟	94
7.11本章小结	94
第8章 方法区	95
	8.1 栈、堆、方法区的交互关系	95
	8.2 方法区的理解	96
		8.2.1 方法区的官方描述	96
		8.2.2 方法区的基本理解	97
		8.2.3 JDK中方法区的变化	97
	8.3 设置方法区大小与OOM	98
		8.3.1 设置方法区内存的大小	98
		8.3.2 方法区内存溢出	100
	8.4 方法区的内部结构	101
		8.4.1 类型信息、域信息和方法信息介绍	102
		8.4.2 类变量和常量	106
		8.4.3 常量池	107
		8.4.4 运行时常量池	109
	8.5 方法区使用举例	110
	8.6 方法区的演进细节	114
		8.6.1 HotSpot虚拟机中方法区的变化	114
		8.6.2 永久代为什么被元空间替换	115
		8.6.3 静态变量存放的位置	116
	8.7 方法区的垃圾回收	121
	8.8 本章小结	122
第9章 对象的实例化内存布局与访问定位	123
	9.1 对象的实例化	123
		9.1.1 创建对象的方式	123
		9.1.2 创建对象的步骤	124
	9.2 对象的内存布局	126
	9.3 对象的访问定位	128
		9.3.1 对象访问的定位方式	128
		9.3.2 使用句柄访问	128
		9.3.3 使用指针访间	129
	9.4 本章小结	129
第10章 直接内存	130
	10.1 直接内存概述	130
	10.2 直接内存的优势	131
	10.3 直接内存异常	135
	10.4 申请直接内存源码分析	136
	10.5 本章小结	137
第11章 执行引擎	138
	11.1 概述	138
	11.2 计算机语言的发展史	138
		11.2.1 机器码	138
		11.2.2 汇编语言	139
		11.2.3 高级语言	139
		11.2.4 字节码	139
	11.3 Java代码编译和执行过程	140
	11.4 解释器	142
	11.5 JIT编译器	142
		11.5.1 为什么HotSpot VM同时存在JIT编译器和解释器	143
		11.5.2 热点代码探测确定何时JIT	144
		11.5.3 设置执行模式	146
		11.5.4 C1编译器和C2编译器	147
	11.6 AOT编译器和Graal编译器	148
	11.7本章 总结	148
第12章 字符串常量池	149
	12.1 String的基本特性	149
		12.1.1 String类概述	149
		12.1.2 String的不可变性	150
	12.2 字符串常量池	152
		12.2.1 字符串常量池的大小	152
		12.2.2 字符串常量池的位置	156
		12.2.3 字符串常量对象的共享	157
	12.3 字符串拼接操作	159
		12.3.1 不同方式的字符串拼接	159
		12.3.2 字符串拼接的细节	161
		12.3.3 "+"拼接和StringBuilder拼接效率	162
	12.4 intern()的使用	163
		12.4.1 不同JDK版本的intern()方法	164
		12.4.2 intern()方法的好处	165
	12.5 字符串常量池的垃圾回收	167
	12.6 G1中的String去重操作	168
	12.7 本章小结	169
第13章 垃圾收集概述	171
	13.1 什么是垃圾	171
	13.2 为什么需要垃圾收集	171
	13.3 如何进行垃圾收集	172
		13.3.1 早期垃圾收集	172
		13.3.2 Java垃圾收集机制	172
	13.4 本章小结	173
第14章 垃圾收集相关算法	174
	14.1 对象存活判断	174
		14.1.1 引用计数算法	174
		14.1.2 可达性分析算法	176
	14.2 GC Roots集合	176
		14.2.1 GC Roots	176
		14.2.2 MAT追踪GC Roots的溯源	177
		14.2.3 JProfiler追踪GC Roots的溯源	182
	14.3 对象的finalization机制	186
	14.4 清除垃圾对象	188
		14.4.1 标记–清除算法	188
		14.4.2 复制算法	189
		14.4.3 标记–压缩算法	190
	14.5 垃圾收集算法的复合与升级	191
		14.5.1 分代收集算法	191
		14.5.2 增量收集算法	192
		14.5.3 分区收集算法	193
	14.6 本章小结	193
第15章 垃圾收集相关概念	194
	15.1 System.gc()的理解	194
	15.2 内存溢出与内存泄漏	195
		15.2.1 内存溢出	195
		15.2.2 内存泄漏	196
	15.3 Stop-The-World	201
	15.4 安全点与安全区域	203
		15.4.1 安全点	203
		15.4.2 安全区域	204
	15.5 四种引用	204
		15.5.1 强引用——不回收	205
		15.5.2 软引用——内存不足立即回收	207
		15.5.3 弱引用——发现即回收	209
		15.5.4 虚引用——对象回收跟踪	211
	15.6 本章小结	213
第16章 垃圾收集器	214
	16.1 垃圾收集器的发展和分类	214
		16.1.1 评估垃圾收集器的性能指标	214
		16.1.2 垃圾收集器的发展史	215
		16.1.3 垃圾收集器的分类	216
		16.1.4 查看默认的垃圾收集器	219
	16.2 Serial收集器:串行回收	220
	16.3 ParNew收集器:并行回收	221
	16.4 Parallel Scaveng收集器:吞吐量优先	222
	16.5 CMS收集器:低延迟	223
		16.5.1 CMS收集器介绍	223
		16.5.2 CMS的工作原理	223
		16.5.3 CMS收集器的参数设置	225
		16.5.4 JDK后续版本中CMS的变化	226
	16.6 G1收集器:区域化分代式	226
		16.6.1 G1收集器	226
		16.6.2 G1收集器的特点和使用场景	227
		16.6.3 分区Region:化整为零	228
		16.6.4 G1收集器垃圾回收过程	229
		16.6.5 G1收集器的参数设置	232
	16.7 垃圾收集器的新发展	233
		16.7.1 Epsilon和ZGC	233
		16.7.2 Shenandoah GC	234
	16.8 垃圾收集器总结	234
	16.9 本章小结	235
第17章 class文件结构	237
	17.1 概述	237
		17.1.1 class文件的跨平台性	237
		17.1.2 编译器分类	238
		17.1.3 透过字节码指令看代码细节	239
	17.2 虚拟机的基石:class文件	240
		17.2.1 字节码指令	240
		17.2.2 解读字节码方式	241
	17.3 class文件结构	242
		17.3.1 魔数:class文件的标识	244
		17.3.2 class文件版本号	245
		17.3.3 常量池:存放所有常量	245
		17.3.4 访问标识	251
		17.3.5 类索引、父类索引、接口索引集合	253
		17.3.6 字段表集合	255
		17.3.7 方法表集合	258
		17.3.8 属性表集合	261
	17.4 使用javap指令解析class文件	270
	17.5 本章小结	278
第18章 字节码指令集与解析	279
	18.1 概述	279
		18.1.1 字节码与数据类型	279
		18.1.2 指令分类	280
	18.2 加载与存储指令	280
		18.2.1 局部变量入栈指令	281
		18.2.2 常量入栈指令	283
		18.2.3 出栈装入局部变量表指令	285
	18.3 算术指令	287
		18.3.1 彻底理解i++与++i	288
		18.3.2 比较指令	290
	18.4 类型转换指令	290
		18.4.1 宽化类型转换	290
		18.4.2 窄化类型转换	293
	18.5 对象、数组的创建与访问指令	295
		18.5.1 创建指令	296
		18.5.2 字段访问指令	297
		18.5.3 数组操作指令	300
		18.5.4 类型检查指令	302
	18.6 方法调用与返回指令	303
		18.6.1 方法调用指令	303
		18.6.2 方法返回指令	305
	18.7 操作数栈管理指令	305
	18.8 控制转移指令	312
		18.8.1 条件跳转指令	312
		18.8.2 比较条件跳转指令	313
		18.8.3 多条件分支跳转	315
		18.8.4 无条件跳转	319
	18.9 异常处理指令	320
		18.9.1 抛出异常指令	320
		18.9.2 异常处理和异常表	322
	18.10 同步控制指令	326
		18.10.1 方法内指定指令序列的同步	326
		18.10.2 方法级的同步	328
	18.11 本章小结	328
第19章 类的加载过程详解	329
	19.1 概述	329
	19.2 加载(Loading)阶段	329
		19.2.1 加载完成的操作	329
		19.2.2 二进制流的获取方式	329
		19.2.3 类模型与Class实例的位置	330
		19.2.4 数组类的加载	331
	19.3 链接(Linking)阶段	332
		19.3.1 链接阶段之验证(Verification)	332
		19.3.2 链接阶段之准备(Preparation)	333
		19.3.3 链接阶段之解析(Resolution)	334
	19.4 初始化(Initialization)阶段	335
		19.4.1 static与final搭配	336
		19.4.2 <clinit>()方法的线程安全性	337
		19.4.3 类的初始化时机:主动使用和被动使用	337
	19.5 类的使用(Using)	346
	19.6 类的卸载(Unloading)	346
	19.7 本章小结	348
第20章 类加载器	349
	20.1 概述	349
		20.1.1 类加载的分类	349
		20.1.2 类加载器的必要性	349
		20.1.3 命名空间	349
		20.1.4 类加载机制的基本特征	350
	20.2 类加载器分类	350
		20.2.1 引导类加载器	351
		20.2.2 扩展类加载器	352
		20.2.3 应用程序类加载器	353
		20.2.4 自定义类加载器	355
	20.3 获取不同的类加载器	355
	20.4 类加载器源码解析	357
		20.4.1 ClassLoader的主要方法	362
		20.4.2 SecureClassLoader与URLClassLoader	365
		20.4.3 ExtClassIoader与AppClassLoader	365
		20.4.4 Class.forName()与ClassLoader.loadClass()加载器	365
	20.5 如何自定义类加载器	366
	20.6 双亲委派模型	368
		20.6.1 定义与本质	368
		20.6.2 双亲委派模型的优势与劣势	369
		20.6.3 破坏双亲委派模型	370
		20.6.4 热替换的实现	371
	20.7 沙箱安全机制	373
		20.7.1 JDK1.0时期	373
		20.7.2 JDK1.2时期	374
		20.7.3 JDK1.2时期	374
		20.7.4 JDK1.6时期	374
	20.8 JDK9新特性	375
	20.9 本章小结	377
第21章 命令行工具	379
	21.1 概述	379
	21.2 jps:查看正在运行的Java进程	381
	21.3 jstat:查看JVM统计信息	382
	21.4 jinfo:实时查看和修改JVM配置参数	385
	21.5 jmap:导出内存映像文件和内存使用情况	391
	21.6 jhat:JDK自带堆分析工具	397
	21.7 jstack:打印JVM中线程快照	399
	21.8 jcmd:多功能命令行	402
	21.9 jstatd:远程主机信息收集	406
21.10本章小结	406
第22章 JVM监控及诊断工具	407
	22.1 概述	407
	22.2 jconsole	407
	22.3 VisualVM	413
		22.3.1 插件安装	414
		22.3.2 连接方式	415
		22.3.3 主要功能	416
	22.4 Eclipse MAT	422
		22.4.1 获取堆dump文件	423
		22.4.2 分析堆dump文件	424
		22.4.3 支持使用OQL语言查询对象信息	433
		22.4.4 Tomcat案例分析	438
	22.5 JProfiler	441
		22.5.1 概述	441
		22.5.2 安装与配置	442
		22.5.3 具体使用	445
		22.5.4 案例分析	456
	22.6 Arthas	458
		22.6.1 基本概述	458
		22.6.2 安装与使用	459
		22.6.3 相关诊断命令	462
	22.7 Java Mission Control	476
		22.7.1 概述	476
		22.7.2 安装使用	477
		22.7.3 功能介绍	478
		22.7.4 Java Flight Recorder介绍	481
	22.8 其他工具	484
		22.8.1 TProfiler	484
		22.8.2 Java运行时追踪工具BTrace	485
	22.9 本章小结	485
第23章 JVM运行时参数	486
	23.1 JVM参数选项类型	486
		23.1.1 标准参数选项	486
		23.1.2 非标准参数选项	487
		23.1.3 非稳定参数选项	488
	23.2 添加JVM参数的方式	489
	23.3 常用JVM参数选项	490
	23.4 通过Java代码获取JVM参数	496
	23.5 本章小结	497
第24章 GC日志分析	498
	24.1 概述	498
	24.2 生成GC日志	498
	24.2 Parallel垃圾收集器日志解析	501
		24.3.4 Minor GC	501
		24.3.2 FULL GC	501
	24.4 G1垃圾收集器日志解析	503
		24.4.1 MinorGC	503
		24.4.2 并发收集	505
		24.4.3 混合收集	506
		24.4.4 FullGC	507
	24.5 CMS垃圾收集器日志解析	507
		24.5.1 Minor GC	507
		24.5.2 Major GC	508
		24.5.3 浮动垃圾	511
	24.6 日志解析工具	511
		24.6.1 GCeasy	511
		24.6.2 GCViewer	512
		24.6.3 其他工具	514
	24.7 根据日志信息解析堆空间数据分配	515
	24.8 本章小结	516
第25章 OOM分类及解决方案	517
	25.1 概述	517
	25.2 OOM案例1:堆内存溢出	517
	25.3 OOM案例2:元空间溢出	518
	25.4 OOM案例3:GC overhead limit exceeded	522
	25.5 OOM案例4:线程溢出	525
	25.6 本章小结	527
第26章 性能优化案例	528
	26.1 概述	528
	26.2 性能测试工具:Apache JMeter	528
	26.3 性能优化案例1:调整堆大小提高服务的吞吐量	531
	26.4 性能优化案例2:调整垃圾收集器提高服务的吞吐量	533
	26.5 性能优化案例3:JIT优化	536
	26.6 性能优化案例4:G1并发执行的线程数对性能的影响	537
	26.7 性能优化案例5:合理配置堆内存	539
	26.8 性能优化案例6:CPU占用很高排查方案	543
	26.9 性能优化案例7:日均百万级订单交易系统设置JVM参数	546
	26.10 性能优化案例8:综合性能优化	547
	26.11 本章小结	557